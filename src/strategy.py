"""
Trading Strategy Logic for IBIT Dip Bot.

Implements the optimized "10 AM ET Dip" strategy:
- Monday: Disabled by default (weakest day), optional with higher threshold
- Tuesday-Thursday: Buy if price >= 0.6% below open during 10:00-10:59 AM ET
- Friday: Same buy rule, but must sell at 3:55 PM (never hold over weekend)
- Weekend: Always 100% flat
"""

import datetime
import logging
from dataclasses import dataclass
from datetime import timedelta
from enum import Enum
from typing import Any, Dict, Optional

from .database import Database, get_database
from .etrade_client import ETradeClient
from .utils import (
    calculate_dip_percentage,
    calculate_pnl,
    calculate_shares,
    get_day_of_week,
    get_et_now,
    get_market_times,
    is_friday,
    is_in_dip_window,
    is_monday,
    is_trading_day,
)

logger = logging.getLogger(__name__)


class TradeAction(Enum):
    """Possible trading actions."""

    HOLD = "hold"
    BUY = "buy"
    SELL = "sell"
    WAIT = "wait"  # Not in trading window yet


@dataclass
class StrategyConfig:
    """Configuration for the trading strategy."""

    # Strategy selection
    strategy_type: str = (
        "combined"  # "original_dip", "mean_reversion", "short_thursday", "combined"
    )

    # Original dip strategy thresholds (if using original_dip)
    regular_threshold: float = 0.6  # Default 0.6% for Tue-Fri
    monday_threshold: float = 1.0  # Higher threshold for Monday if enabled
    monday_enabled: bool = False  # Monday disabled by default

    # Mean reversion settings (if using mean_reversion or combined)
    mean_reversion_threshold: float = -3.0  # Buy after X% down day
    skip_thursday_for_mr: bool = True  # Skip Thursday for mean reversion

    # Short Thursday settings (if using short_thursday or combined)
    enable_short_thursday: bool = True  # Short on Thursdays

    # Position sizing
    max_position_usd: Optional[float] = None  # Max $ to invest per trade
    max_position_pct: float = 100.0  # Max % of available cash

    # Order settings
    use_limit_orders: bool = False
    limit_offset_pct: float = 0.05  # Limit price offset from current

    # Mode
    dry_run: bool = False


@dataclass
class StrategyState:
    """Current state of the strategy."""

    has_position: bool = False
    position_shares: int = 0
    position_entry_price: float = 0.0
    position_date: Optional[str] = None
    open_price: Optional[float] = None
    current_price: Optional[float] = None
    dip_percentage: float = 0.0
    is_paused: bool = False
    pause_reason: Optional[str] = None


@dataclass
class TradeSignal:
    """Signal generated by strategy analysis."""

    action: TradeAction
    reason: str
    dip_percentage: float = 0.0
    shares: int = 0
    price: float = 0.0
    threshold_used: float = 0.0


class IBITDipStrategy:
    """
    IBIT Dip Trading Strategy.

    Core Rules:
    1. Capture open price at 9:30 AM ET
    2. During 10:00-10:59 AM ET, check if price has dipped >= threshold
    3. If dip condition met, buy IBIT with available cash
    4. Sell at 4:00 PM ET (3:55 PM on Fridays)
    5. Never hold positions overnight, especially over weekends
    """

    def __init__(
        self,
        client: ETradeClient,
        config: Optional[StrategyConfig] = None,
        db: Optional[Database] = None,
        account_id_key: Optional[str] = None,
    ):
        """
        Initialize strategy.

        Args:
            client: E*TRADE client for API calls
            config: Strategy configuration
            db: Database for state persistence
            account_id_key: E*TRADE account to trade in
        """
        self.client = client
        self.config = config or StrategyConfig()
        self.db = db or get_database()
        self.account_id_key = account_id_key
        self._state: Optional[StrategyState] = None

    def get_state(self) -> StrategyState:
        """Get current strategy state."""
        if self._state is None:
            self._refresh_state()
        return self._state

    def _refresh_state(self):
        """Refresh state from database and current prices."""
        bot_state = self.db.get_bot_state()
        now = get_et_now()

        # Check for open position
        open_trade = self.db.get_open_trade()
        has_position = open_trade is not None

        # Get current price
        current_price = None
        open_price = None
        dip_pct = 0.0

        try:
            quote = self.client.get_ibit_quote()
            current_price = quote.get("last_price")
            open_price = self.db.get_open_price(now.date())

            if open_price is None:
                # Try to get from quote if market just opened
                open_price = quote.get("open_price")

            if open_price and current_price:
                dip_pct = calculate_dip_percentage(open_price, current_price)
        except Exception as e:
            logger.warning(f"Failed to get quote: {e}")

        # Check pause state
        is_paused = bool(bot_state.get("is_paused"))
        pause_until = bot_state.get("pause_until")
        pause_reason = None

        if is_paused and pause_until:
            from datetime import datetime

            pause_dt = datetime.fromisoformat(pause_until)
            if now >= pause_dt:
                # Pause expired
                is_paused = False
                self.db.set_paused(False)
            else:
                pause_reason = f"Paused until {pause_until}"

        self._state = StrategyState(
            has_position=has_position,
            position_shares=open_trade["shares"] if open_trade else 0,
            position_entry_price=open_trade["entry_price"] if open_trade else 0.0,
            position_date=open_trade["date"] if open_trade else None,
            open_price=open_price,
            current_price=current_price,
            dip_percentage=dip_pct,
            is_paused=is_paused,
            pause_reason=pause_reason,
        )

    def analyze(self) -> TradeSignal:
        """
        Analyze current market conditions and generate trade signal.

        Returns:
            TradeSignal with recommended action
        """
        self._refresh_state()
        state = self._state
        now = get_et_now()
        times = get_market_times(now.date())

        # Check if paused
        if state.is_paused:
            return TradeSignal(
                action=TradeAction.HOLD, reason=f"Bot is paused: {state.pause_reason}"
            )

        # Check if it's a trading day
        if not is_trading_day(now.date()):
            # If we have a position, we need to close it (shouldn't happen)
            if state.has_position:
                return self._generate_sell_signal("Position held on non-trading day - closing")
            return TradeSignal(action=TradeAction.HOLD, reason="Not a trading day")

        # Check if market is open
        if now < times["market_open"]:
            return TradeSignal(action=TradeAction.WAIT, reason="Market not open yet")

        if now > times["market_close"]:
            return TradeSignal(action=TradeAction.HOLD, reason="Market closed")

        # === SELL LOGIC ===

        # If we have a position, check if we should sell
        if state.has_position:
            # Friday: Must sell by 3:55 PM
            if is_friday() and now >= times["friday_close"]:
                return self._generate_sell_signal("Friday close - selling to avoid weekend hold")

            # Regular days: Sell at 4:00 PM
            if now >= times["market_close"] - timedelta(minutes=2):
                return self._generate_sell_signal("Market close approaching - executing exit")

            # Otherwise hold
            unrealized_pnl = 0.0
            if state.current_price and state.position_entry_price:
                unrealized_pnl = (
                    (state.current_price - state.position_entry_price)
                    / state.position_entry_price
                    * 100
                )
            return TradeSignal(
                action=TradeAction.HOLD,
                reason=f"Holding position. Unrealized: {unrealized_pnl:+.2f}%",
                price=state.current_price or 0,
            )

        # === BUY LOGIC ===

        # Check if Monday trading is disabled
        if is_monday() and not self.config.monday_enabled:
            return TradeSignal(
                action=TradeAction.HOLD,
                reason="Monday trading disabled",
                dip_percentage=state.dip_percentage,
            )

        # Check if we're in the dip window (10:00-10:59 AM)
        if not is_in_dip_window():
            if now < times["dip_window_start"]:
                return TradeSignal(
                    action=TradeAction.WAIT,
                    reason="Waiting for dip window (10:00 AM ET)",
                    dip_percentage=state.dip_percentage,
                )
            else:
                return TradeSignal(
                    action=TradeAction.HOLD,
                    reason="Dip window passed (after 11:00 AM)",
                    dip_percentage=state.dip_percentage,
                )

        # We're in the dip window - check threshold
        threshold = self.config.monday_threshold if is_monday() else self.config.regular_threshold

        if state.open_price is None:
            return TradeSignal(
                action=TradeAction.WAIT,
                reason="No open price captured yet",
                threshold_used=threshold,
            )

        if state.current_price is None:
            return TradeSignal(
                action=TradeAction.WAIT,
                reason="Unable to get current price",
                threshold_used=threshold,
            )

        # Check if dip meets threshold
        if state.dip_percentage >= threshold:
            return self._generate_buy_signal(threshold)
        else:
            return TradeSignal(
                action=TradeAction.HOLD,
                reason=f"Dip {state.dip_percentage:.2f}% < threshold {threshold:.2f}%",
                dip_percentage=state.dip_percentage,
                threshold_used=threshold,
                price=state.current_price,
            )

    def _generate_buy_signal(self, threshold: float) -> TradeSignal:
        """Generate buy signal with position sizing."""
        state = self._state

        # Calculate position size
        try:
            cash = self.client.get_cash_available(self.account_id_key) if self.account_id_key else 0

            if self.config.max_position_usd:
                max_cash = min(cash, self.config.max_position_usd)
            else:
                max_cash = cash * (self.config.max_position_pct / 100)

            shares = calculate_shares(max_cash, state.current_price)

        except Exception as e:
            logger.error(f"Failed to calculate position size: {e}")
            shares = 0

        if shares <= 0:
            return TradeSignal(
                action=TradeAction.HOLD,
                reason="Insufficient cash for trade",
                dip_percentage=state.dip_percentage,
                threshold_used=threshold,
            )

        return TradeSignal(
            action=TradeAction.BUY,
            reason=f"Dip {state.dip_percentage:.2f}% >= threshold {threshold:.2f}%",
            dip_percentage=state.dip_percentage,
            shares=shares,
            price=state.current_price,
            threshold_used=threshold,
        )

    def _generate_sell_signal(self, reason: str) -> TradeSignal:
        """Generate sell signal for current position."""
        state = self._state

        return TradeSignal(
            action=TradeAction.SELL,
            reason=reason,
            shares=state.position_shares,
            price=state.current_price or 0,
        )

    def execute(self, signal: TradeSignal) -> Dict[str, Any]:
        """
        Execute a trade signal.

        Args:
            signal: TradeSignal from analyze()

        Returns:
            Dict with execution results
        """
        if signal.action not in (TradeAction.BUY, TradeAction.SELL):
            return {"success": False, "reason": f"No action: {signal.action.value}"}

        if not self.account_id_key:
            return {"success": False, "reason": "No account configured"}

        try:
            if signal.action == TradeAction.BUY:
                return self._execute_buy(signal)
            else:
                return self._execute_sell(signal)
        except Exception as e:
            logger.error(f"Trade execution failed: {e}")
            self.db.log_event("ERROR", "Trade execution failed", {"error": str(e)})
            return {"success": False, "reason": str(e)}

    def _execute_buy(self, signal: TradeSignal) -> Dict[str, Any]:
        """Execute buy order."""
        state = self._state
        now = get_et_now()

        logger.info(f"Executing BUY: {signal.shares} shares @ ${signal.price:.2f}")

        # Preview order
        preview = self.client.preview_order(
            self.account_id_key,
            "IBIT",
            "BUY",
            signal.shares,
            order_type="LIMIT" if self.config.use_limit_orders else "MARKET",
            limit_price=signal.price * (1 + self.config.limit_offset_pct / 100)
            if self.config.use_limit_orders
            else None,
        )

        preview_ids = preview.get("PreviewIds", [])

        # Place order
        result = self.client.place_order(
            self.account_id_key,
            "IBIT",
            "BUY",
            signal.shares,
            order_type="LIMIT" if self.config.use_limit_orders else "MARKET",
            limit_price=signal.price * (1 + self.config.limit_offset_pct / 100)
            if self.config.use_limit_orders
            else None,
            preview_ids=preview_ids,
        )

        order_ids = result.get("OrderIds", [])
        order_id = order_ids[0].get("orderId") if order_ids else None

        # Record trade in database
        trade_id = self.db.record_trade_entry(
            date=now.date(),
            day_of_week=get_day_of_week(),
            open_price=state.open_price,
            entry_price=signal.price,
            dip_percentage=signal.dip_percentage,
            shares=signal.shares,
            is_dry_run=self.config.dry_run,
            notes=f"Order ID: {order_id}",
        )

        # Update bot state
        self.db.set_position(signal.shares, signal.price, now.date())

        # Log event
        self.db.log_event(
            "INFO",
            "BUY executed",
            {
                "trade_id": trade_id,
                "order_id": order_id,
                "shares": signal.shares,
                "price": signal.price,
                "dip_pct": signal.dip_percentage,
            },
        )

        logger.info(f"BUY executed: Trade ID {trade_id}, Order ID {order_id}")

        return {
            "success": True,
            "action": "BUY",
            "trade_id": trade_id,
            "order_id": order_id,
            "shares": signal.shares,
            "price": signal.price,
            "dip_percentage": signal.dip_percentage,
        }

    def _execute_sell(self, signal: TradeSignal) -> Dict[str, Any]:
        """Execute sell order."""
        _state = self._state  # noqa: F841 - reserved for future use
        _now = get_et_now()  # noqa: F841 - reserved for future use

        logger.info(f"Executing SELL: {signal.shares} shares @ ${signal.price:.2f}")

        # Get open trade
        open_trade = self.db.get_open_trade()
        if not open_trade:
            return {"success": False, "reason": "No open position to sell"}

        # Preview order
        preview = self.client.preview_order(
            self.account_id_key, "IBIT", "SELL", signal.shares, order_type="MARKET"
        )

        preview_ids = preview.get("PreviewIds", [])

        # Place order
        result = self.client.place_order(
            self.account_id_key,
            "IBIT",
            "SELL",
            signal.shares,
            order_type="MARKET",
            preview_ids=preview_ids,
        )

        order_ids = result.get("OrderIds", [])
        order_id = order_ids[0].get("orderId") if order_ids else None

        # Calculate P&L
        entry_price = open_trade["entry_price"]
        dollar_pnl, pct_pnl = calculate_pnl(entry_price, signal.price, signal.shares)

        # Record exit
        self.db.record_trade_exit(
            trade_id=open_trade["id"],
            exit_price=signal.price,
            dollar_pnl=dollar_pnl,
            percentage_pnl=pct_pnl,
        )

        # Clear position
        self.db.clear_position()

        # Update stats
        bot_state = self.db.get_bot_state()
        self.db.update_bot_state(
            total_trades=(bot_state.get("total_trades", 0) or 0) + 1,
            winning_trades=(bot_state.get("winning_trades", 0) or 0) + (1 if pct_pnl > 0 else 0),
            total_pnl=(bot_state.get("total_pnl", 0) or 0) + dollar_pnl,
        )

        # Log event
        self.db.log_event(
            "INFO",
            "SELL executed",
            {
                "trade_id": open_trade["id"],
                "order_id": order_id,
                "shares": signal.shares,
                "entry_price": entry_price,
                "exit_price": signal.price,
                "dollar_pnl": dollar_pnl,
                "pct_pnl": pct_pnl,
            },
        )

        logger.info(f"SELL executed: P&L ${dollar_pnl:+.2f} ({pct_pnl:+.2f}%)")

        return {
            "success": True,
            "action": "SELL",
            "trade_id": open_trade["id"],
            "order_id": order_id,
            "shares": signal.shares,
            "entry_price": entry_price,
            "exit_price": signal.price,
            "dollar_pnl": dollar_pnl,
            "percentage_pnl": pct_pnl,
        }

    def capture_open_price(self) -> Optional[float]:
        """
        Capture and store the market open price for today.
        Should be called at 9:30 AM ET.
        """
        now = get_et_now()

        if not is_trading_day(now.date()):
            logger.info("Not a trading day, skipping open price capture")
            return None

        try:
            quote = self.client.get_ibit_quote()
            open_price = quote.get("open_price") or quote.get("last_price")

            if open_price:
                self.db.store_open_price(now.date(), open_price)
                logger.info(f"Captured open price: ${open_price:.2f}")
                return open_price
            else:
                logger.warning("Failed to get open price from quote")
                return None

        except Exception as e:
            logger.error(f"Failed to capture open price: {e}")
            return None

    def force_buy(self, shares: Optional[int] = None) -> Dict[str, Any]:
        """Force a buy order regardless of strategy signals."""
        self._refresh_state()
        state = self._state

        if state.has_position:
            return {"success": False, "reason": "Already have a position"}

        if state.current_price is None:
            try:
                quote = self.client.get_ibit_quote()
                state.current_price = quote.get("last_price")
            except Exception as e:
                return {"success": False, "reason": f"Cannot get price: {e}"}

        # Calculate shares if not specified
        if shares is None:
            cash = self.client.get_cash_available(self.account_id_key) if self.account_id_key else 0
            max_cash = cash
            if self.config.max_position_usd:
                max_cash = min(cash, self.config.max_position_usd)
            shares = calculate_shares(max_cash, state.current_price)

        signal = TradeSignal(
            action=TradeAction.BUY,
            reason="Force buy",
            dip_percentage=state.dip_percentage,
            shares=shares,
            price=state.current_price,
        )

        return self.execute(signal)

    def force_sell(self) -> Dict[str, Any]:
        """Force a sell order regardless of strategy signals."""
        self._refresh_state()
        state = self._state

        if not state.has_position:
            return {"success": False, "reason": "No position to sell"}

        if state.current_price is None:
            try:
                quote = self.client.get_ibit_quote()
                state.current_price = quote.get("last_price")
            except Exception as e:
                return {"success": False, "reason": f"Cannot get price: {e}"}

        signal = TradeSignal(
            action=TradeAction.SELL,
            reason="Force sell",
            shares=state.position_shares,
            price=state.current_price,
        )

        return self.execute(signal)

    def pause_until_tuesday(self):
        """Pause trading until next Tuesday."""
        from datetime import timedelta

        now = get_et_now()

        # Find next Tuesday
        days_until_tuesday = (1 - now.weekday()) % 7
        if days_until_tuesday == 0:
            days_until_tuesday = 7  # Next week's Tuesday

        next_tuesday = now.date() + timedelta(days=days_until_tuesday)
        pause_until = datetime.datetime(
            next_tuesday.year, next_tuesday.month, next_tuesday.day, 9, 30, tzinfo=now.tzinfo
        )

        self.db.set_paused(True, pause_until)
        self.db.log_event("INFO", "Bot paused", {"until": pause_until.isoformat()})

        logger.info(f"Bot paused until {pause_until}")
